#!/bin/bash

log() {
    # Write command to log file. If no args are entered, open an input stream.
    if [ $# -gt 0 ]; then
        printf "%s: %s\n" "$(date +'%Y%m%d %H:%M:%S')" "$@" >> "$LOG_FILE"
    else
        cat >> "$LOG_FILE"
    fi
}

usage() {
    echo "Usage build-images <build|dump|commands> <recipe file> <target directory>"
    exit 1
}

fail() {
    echo "Error: $1" >&2
    exit 1
}

check_var() {
    # Utility function for ensuring that a set of variables is defined.
    for var in "$@"; do
        if [ -z "${!var:-}" ]; then
            fail "$var is not set or empty"
            exit 1
        fi
    done
}

check_bash_features() {
    # Ensure shell has features required by build pipeline.
    #
    if ! local -n test_nameref &>/dev/null; then
        echo "Error: Your Bash version does not support namerefs (-n)." >&2
        return 1
    fi
    if ! typeset -A test_array &>/dev/null; then
        echo "Error: Your Bash version does not support associative arrays." >&2
        return 1
    fi
}


get_existing_images() {
    # Query container engine for all existing images.
    podman images --format json | jq -r -c '.[] | select(.Names != null and .Names != []) | .Names[]'
}


get_latest_image_by_lineage() {
    # If image(s) with given name and lineage exists, return the name of the latest one.
    #
    local IMAGE_NAME=$1
    local IMAGE_LINEAGE=$2
    local TAG_PATTERN=":[0-9]{8}_[0-9]{6}$"
    local JQ_COMMAND='
        [.[]
          | select(
              (.Names[]? | test("/"+$name+$pattern))
              and
              (.Labels["cf_lineage"] == $lineage)
            )
        ]
        | (max_by(.Created)?
           | .Names // []
           | sort
           | map(select(test($pattern)))
           | last // empty)
    '

    podman images --format json | jq -r --arg name "$IMAGE_NAME" --arg lineage "$IMAGE_LINEAGE" --arg pattern "$TAG_PATTERN" "$JQ_COMMAND"

    if [[ -n "$LATEST_TAG" ]]; then
        echo "${IMAGE_NAME}:${LATEST_TAG}"
    fi
}


get_image_tag() {
    # If the given image string has tag part, print it.
    #
    local IMAGE="$1"

    if [[ "$IMAGE" == *:* ]]; then
        echo "${IMAGE#*:}"
    fi
}

get_image_name() {
    # Print image name without tag.
    #
    local IMAGE="$1"

    if [[ "$IMAGE" == *:* ]]; then
        echo "${IMAGE%:*}"
    else
        echo "$IMAGE"
    fi
}

export_image() {
    # Export OCI archive produced by Podman into Singularity image file.
    #
    local IMAGE_NAME=$1
    local IMAGE_TAG=$2
    local EXPORT_IMAGE_NAME=$3
    local EXPORT_SIF_DEF=$4

    local OCI_FILE="${BUILD_DIR}/${EXPORT_IMAGE_NAME}-${IMAGE_TAG}.tar"
    local DEF_FILE="${BUILD_DIR}/${EXPORT_IMAGE_NAME}-${IMAGE_TAG}.def"
    local SIF_FILE="${BUILD_DIR}/${EXPORT_IMAGE_NAME}-${IMAGE_TAG}.sif"

    local OCI_COMMAND="podman image save --format oci-archive ${IMAGE_NAME}:${IMAGE_TAG} -o $OCI_FILE"

    printf 'Bootstrap: oci-archive\nFrom: %s\n%s\n' "${OCI_FILE}" "${EXPORT_SIF_DEF}" > "$DEF_FILE"

    local SIF_COMMAND="singularity build ${SIF_FILE} ${DEF_FILE}"

    log "*** Exporting image with command $OCI_COMMAND"
    ${OCI_COMMAND[@]} 2>&1 | sed -e 's/^/    /' | log

    log "*** Creating sif file with command $SIF_COMMAND"
    ${SIF_COMMAND[@]} 2>&1 | sed -e 's/^/    /' | log

    log "*** Image checksums:"
    sha256sum "$OCI_FILE" "$SIF_FILE" | sed -e 's/^/    /' | log
}


parse_step() {
    local STEP_JSON=$1
    local -n STEP_DATA=$2

    STEP_DATA["IMAGE_NAME"]=$(jq -r '.name' <<< "$STEP_JSON")
    STEP_DATA["IMAGE_TAG"]=${BUILD_TAG}
    STEP_DATA["IMAGE_DESCRIPTION"]=$(jq -r '.desc' <<< "$STEP_JSON")

    STEP_DATA["EXPORT_IMAGE_NAME"]=$(jq -r '.export.name // ""' <<< "$STEP_JSON")
    STEP_DATA["EXPORT_SIF_DEF"]=$(jq -r '.export.def // ""' <<< "$STEP_JSON")

    # The first image in the chain of images we build differs from all
    # other images in that it has its base image fetched externally and
    # not built locally. To make the builds as deterministic as possible,
    # for now lets require the tag to be pre-determined, i.e. part of the
    # rendered recipe. This also makes the tag be part of the cf_hash and
    # cf_lineage fields. The value of cf_hash is the sha1 checksum of the
    # rendered Containerfile used to build the image. The cf_lineage is
    # comma separated list of Containerfile hashes of part images and our
    # own hash. For the 'first-in-the-chain' images the cf_hash includes
    # the base image tag (as it's pre-determined), but for all other images
    # the tag is determined at build time. This means that for these images
    # the cf_hash is the sha1 of the final Containerfile content without
    # the line specifying the BASE_IMAGE_TAG. The 'first-in-the-chain'
    # images also have another speciality, which is that their cf_lineage
    # and cf_hash are the same as there's no parent Containerfile for them.

    STEP_DATA["BASE_IMAGE"]=$(jq -r '.base' <<< "$STEP_JSON")
    STEP_DATA["CF_HASH"]=$(jq -r '.cf_hash' <<< "$STEP_JSON")
    STEP_DATA["CF_LINEAGE"]=$(jq -r '.cf_lineage' <<< "$STEP_JSON")
    STEP_DATA["CF_TEMPLATE"]=$(jq -r '.template' <<< "$STEP_JSON")
    STEP_DATA["CF_NAME"]=$(printf "%s-%s.Containerfile" ${STEP_DATA["IMAGE_NAME"]} ${STEP_DATA["IMAGE_TAG"]})

    # revisit: cleanup needed, this looks messy
    #
    # Let's figure out if we are dealing with a first-in-the-chain image
    if [[ "${STEP_DATA['CF_HASH']}" == "${STEP_DATA['CF_LINEAGE']}" ]]; then
        STEP_DATA["FIRST_IN_CHAIN"]=1

        # We have a external upstream parent such as "ubuntu:abc", then
        # the tag is included in the cf_text and cf_hash.
        STEP_DATA["BASE_IMAGE_TAG"]="$(get_image_tag ${STEP_DATA['BASE_IMAGE']})"
        STEP_DATA["BASE_IMAGE"]="$(get_image_name ${STEP_DATA["BASE_IMAGE"]})"
        # No need to add the base image tag here
        STEP_DATA["CF_CONTENT"]=$(jq -r '.cf_text' <<< "$STEP_JSON")
    else
        STEP_DATA["FIRST_IN_CHAIN"]=0
        # Deleting everything after the last comma gives us the parent cf_lineage.
        STEP_DATA["CF_PARENT"]=$(sed 's/,[^,]*$//' <<< "${STEP_DATA['CF_LINEAGE']}")

        local EXISTING_PARENT="$(get_latest_image_by_lineage ${STEP_DATA["IMAGE_NAME"]} ${STEP_DATA['CF_PARENT']})"

        if [[ -n "$EXISTING_PARENT" ]]; then
            # We may or may not be using this exact image. To be sure, we would need to peek at the previous steps.
            # however, this is an issue only with the "commands" and "dump" options, as whether we build it or not,
            # at this stage, we will get the correct parent with the "build" as the latest would be one we built.
            STEP_DATA["BASE_IMAGE_TAG"]="$(get_image_tag ${EXISTING_PARENT})"
        else
            # It doesn't exist, it will be built and it will have the tag of the ongoing build
            STEP_DATA["BASE_IMAGE_TAG"]=${BUILD_TAG}
        fi

        local CF_HEADER="# Start of dynamically injected content"
        local CF_EXTRA="ARG BASE_IMAGE_TAG=${STEP_DATA["BASE_IMAGE_TAG"]}"
        local CF_FOOTER="# End of dynamically injected content"
        local CF_TEXT=$(jq -r '.cf_text' <<< "$STEP_JSON")

        STEP_DATA["CF_CONTENT"]="$CF_HEADER"$'\n'"$CF_EXTRA"$'\n'"$CF_FOOTER"$'\n'"$CF_TEXT"

    fi

    STEP_DATA["EXISTING_IMAGE"]="$(get_latest_image_by_lineage ${STEP_DATA["IMAGE_NAME"]} ${STEP_DATA['CF_LINEAGE']})"

    if [[ ${LAIFS_CONTAINER_RECIPES_FORCE_BUILD} == "true" ]]; then
        STEP_DATA["FORCE_NEW"]="true"
    else
        STEP_DATA["FORCE_NEW"]=$(jq -r '.force // "false"' <<< "$STEP_JSON")
    fi

    local ENV_ARGS=$(jq -r '.env.[]|split("=")|"ARG \(.[0])=\(.[1])"' <<< "$STEP_JSON")
    local BUILD_ARGS=$(printf "%s\n%s" "$BASE_ARGS" "$ENV_ARGS")

    if [[ -n "${STEP_DATA['EXISTING_IMAGE']}" && "${STEP_DATA["FORCE_NEW"]}" != "true" ]]; then
        STEP_DATA["SKIP_BUILD"]="true"
    else
        STEP_DATA["SKIP_BUILD"]="false"
    fi

    local BUILD_COMMAND=(
        podman build -f "$BUILD_DIR/${STEP_DATA['CF_NAME']}"
        --cgroup-manager cgroupfs
        --label cf_lineage="${STEP_DATA['CF_LINEAGE']}"
        -t "${STEP_DATA['IMAGE_NAME']}:${STEP_DATA['IMAGE_TAG']}"
        -t "${STEP_DATA['IMAGE_NAME']}:latest"
    )

    STEP_DATA["BUILD_COMMAND"]="${BUILD_COMMAND[@]}"
}


build_image() {

    local STEP_JSON="$1"
    declare -A STEP
    parse_step "$STEP_JSON" STEP

    LOG_FILE=$(printf "${BUILD_DIR}/%s-%s.log" "${STEP['IMAGE_NAME']}" "${STEP['IMAGE_TAG']}")

    echo "Build image ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']} started at $(date)"
    echo "Logging to $LOG_FILE"

    if [[ ${STEP['SKIP_BUILD']} == "true" ]]; then
        log "Skipping build for ${STEP['IMAGE_NAME']}. Using existing image ${STEP['EXISTING_IMAGE']}:"
        podman image inspect ${STEP['EXISTING_IMAGE']} | log
        return
    fi

    if [[ -z "${STEP['BASE_IMAGE_TAG']}" ]]; then
        fail "TAG for BASE_IMAGE \"${STEP['BASE_IMAGE']}\" could not be determined"
    fi

    #check_var RECIPE BASE_IMAGE BUILD_ENV CONTAINERFILE FORCE_NEW IMAGE_NAME

    echo "${STEP['CF_CONTENT']}" > "${BUILD_DIR}/${STEP['CF_NAME']}"

    log "*** Building image ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']} started"
    log "*** Containerfile sha256 sum $(sha256sum "${BUILD_DIR}/${STEP['CF_NAME']}")"
    log "*** Base image: ${STEP['BASE_IMAGE']}:${STEP['BASE_IMAGE_TAG']}"
    log "*** Running build command: ${STEP['BUILD_COMMAND']}"

    eval "${STEP['BUILD_COMMAND']}" 2>&1 | log

    if [[ $? != 0 ]]; then
        fail "Build of ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']} seems to have failed."
    fi

    image_id=$(podman image inspect "${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']}" | jq -r 'first|.Id')

    if [[ $? != 0 ]] || [[ -z "$image_id" ]]; then
        fail "Building image ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']} failed. Could not detemine id for the produced image."
    fi

    log "*** Image info:"
    podman image inspect $image_id| sed -e 's/^/    /' | log

    if [[ -n "${STEP['EXPORT_IMAGE_NAME']}" ]]; then
        export_image "${STEP['IMAGE_NAME']}" "${STEP['IMAGE_TAG']}" "${STEP['EXPORT_IMAGE_NAME']}" "${STEP['EXPORT_SIF_DEF']}"
    fi

    log "*** Building image ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']} completed at $(date)"

    echo "Building ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']} completed at $(date)"
}

build_images() {
    # Execute all build steps from a recipe
    #
    echo "Building images from recipe $(yq . $RECIPE_FILE | jq -r '.name') at $RECIPE_FILE"

    BUILD_TAG=$(yq . $RECIPE_FILE | jq -r '.tag')

    yq -c . $RECIPE_FILE | jq -c '.steps.[]' | while IFS= read -r step; do
        build_image "${step}"
    done
}

dump_recipe() {

    BUILD_TAG=$(yq . $RECIPE_FILE | jq -r '.tag')

    # Print internal representation of each step of a recipe
    echo -e "Recipe $(yq . $RECIPE_FILE | jq -r '.name') from file $RECIPE_FILE:\n"

    yq -c . $RECIPE_FILE | jq -c '.steps.[]' | while IFS= read -r step_json; do
        declare -A step_data
        declare -p step_json
        parse_step "$step_json" step_data

        echo "  ${step_data['IMAGE_NAME']}"
        echo "    spec: $step_json"
        echo "    data:"

        for key in "${!step_data[@]}"; do
            printf "      %s: %s\n" $key "${step_data[$key]//$'\n'/\\n}"
        done

        echo
    done

}

show_commands() {

    BUILD_TAG=$(yq . $RECIPE_FILE | jq -r '.tag')

    # Perform a dry run based on generated recipe
    yq -c . $RECIPE_FILE | jq -c '.steps.[]' | while IFS= read -r step_json; do
        declare -A step_data
        parse_step "$step_json" step_data
        echo "${step_data['IMAGE_NAME']}:${step_data['IMAGE_TAG']}: ${step_data['BUILD_COMMAND']}"
        echo
    done
}

main() {
    # Set shell options
    set -e  # Exit on non-zero exit status
    #set -x  # Print executed commands

    # Ensure availability of required shell features
    if ! check_bash_features; then
        exit 1
    fi

    # If invalid number of arguments provided, print usage instructions
    if [ "$#" -ne 2 ] && [ "$#" -ne 3 ]; then
        usage
    fi

    # If invalid action provided, print usage instructions
    ACTION=$1
    if [ "$ACTION" != "build" ] && [ "$ACTION" != "dump" ] && [ "$ACTION" != "commands" ]; then
        usage
    fi

    # Ensure provided recipe file exists
    RECIPE_FILE=$2
    if [ ! -f "$RECIPE_FILE" ]; then
        echo "Error: Recipe file '$RECIPE_FILE' not found or not a file."
        usage
    fi

    # Ensure build directory exists, if provided
    if [ "$#" -eq 3 ]; then
        BUILD_DIR=$3
        if [ ! -d "$BUILD_DIR" ]; then
            echo "Error: Target directory '$BUILD_DIR' does not exist."
            usage
        fi
    fi

    # Execute provided action
    case "$ACTION" in
        "build")
            build_images $RECIPE_FILE
            ;;
        "dump")
            dump_recipe $RECIPE_FILE
            ;;
        "commands")
            show_commands $RECIPE_FILE
            ;;
        *)
            usage
            ;;
    esac
}

main "$@"
