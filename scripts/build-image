#!/bin/bash

log() {
    # Write command to log file. If no args are entered, open an input stream.
    if [ $# -gt 0 ]; then
        printf "%s: %s\n" "$(date +'%Y%m%d %H:%M:%S')" "$@" | tee -a "$LOG_FILE"
    else
        tee -a "$LOG_FILE"
    fi
}

usage() {
    echo "Usage build-image <build|dump|commands> <recipe file> [<target directory>]"
    exit 1
}

fail() {
    echo "Error: $1" >&2
    exit 1
}

check_var() {
    # Utility function for ensuring that a set of variables is defined.
    for var in "$@"; do
        if [ -z "${!var:-}" ]; then
            fail "$var is not set or empty"
            exit 1
        fi
    done
}

check_bash_features() {
    # Ensure shell has features required by build pipeline.
    #
    if ! local -n test_nameref &>/dev/null; then
        echo "Error: Your Bash version does not support namerefs (-n)." >&2
        return 1
    fi
    if ! typeset -A test_array &>/dev/null; then
        echo "Error: Your Bash version does not support associative arrays." >&2
        return 1
    fi
}


get_existing_images() {
    # Query container engine for all existing images.
    podman images --format json | jq -r -c '.[] | select(.Names != null and .Names != []) | .Names[]'
}

get_latest_tag_for_image() {
    local IMAGE_NAME=$1

    grep -o -P "${IMAGE_NAME}:\d{8}_\d{6}" <<< "$(get_existing_images) " | sort -n | tail -1 | cut -d ':' -f2
}

get_latest_image() {
    # If tags exist for an image, return the latest one.
    # Otherwise return empty string.
    #
    local IMAGE_NAME=$1
    local LATEST_TAG=$(get_latest_tag_for_image "$IMAGE_NAME")

    if [[ -n "$LATEST_TAG" ]]; then
        echo "${IMAGE_NAME}:${LATEST_TAG}"
    else
        echo ""
    fi
}

get_image_tag() {
    # If the given image string has tag, return that, otherwise return the latest tag
    # from existing images using get_latest_tag_for_image.
    #
    local IMAGE="$1"

    if [[ "$IMAGE" == *:* ]]; then
        echo "${IMAGE#*:}"
        return 0
    fi

    local LATEST_TAG=$(get_latest_tag_for_image "$IMAGE")

    echo "$LATEST_TAG"
}

get_image_name() {
    # Print image name without tag
    #
    local IMAGE="$1"

    if [[ "$IMAGE" == *:* ]]; then
        echo "${IMAGE%:*}"
    else
        echo "$IMAGE"
    fi
}

export_image() {
    # Export OCI archive produced by Podman into Singularity image file.
    #
    local IMAGE_NAME=$1
    local IMAGE_TAG=$2
    local EXPORT_IMAGE_NAME=$3
    local EXPORT_SIF_DEF=$4

    local OCI_FILE="${BUILD_DIR}/${EXPORT_IMAGE_NAME}-${IMAGE_TAG}.tar"
    local DEF_FILE="${BUILD_DIR}/${EXPORT_IMAGE_NAME}-${IMAGE_TAG}.def"
    local SIF_FILE="${BUILD_DIR}/${EXPORT_IMAGE_NAME}-${IMAGE_TAG}.sif"

    local OCI_COMMAND="podman image save --format oci-archive ${IMAGE_NAME}:${IMAGE_TAG} -o $OCI_FILE"

    printf 'Bootstrap: oci-archive\nFrom: %s\n%s\n' "${OCI_FILE}" "${EXPORT_SIF_DEF}" > "$DEF_FILE"

    local SIF_COMMAND="singularity build ${SIF_FILE} ${DEF_FILE}"

    log "*** Exporting image with command $OCI_COMMAND"
    ${OCI_COMMAND[@]} | log

    log "*** Creating sif file with command $SIF_COMMAND"
    ${SIF_COMMAND[@]} | log

    log "*** Image checksums:"
    sha256sum "$OCI_FILE" "$SIF_FILE" | log
}

parse_step() {
    local STEP_JSON=$1
    local -n STEP_DATA=$2

    STEP_DATA["BASE_IMAGE"]=$(jq -r '.base' <<< "$STEP_JSON")
    STEP_DATA["FORCE_NEW"]=$(jq -r '.force // "false"' <<< "$STEP_JSON")
    STEP_DATA["IMAGE_NAME"]=$(jq -r '.name' <<< "$STEP_JSON")
    STEP_DATA["EXPORT_IMAGE_NAME"]=$(jq -r '.export.name // ""' <<< "$STEP_JSON")
    STEP_DATA["EXPORT_SIF_DEF"]=$(jq -r '.export.def // ""' <<< "$STEP_JSON")
    STEP_DATA["IMAGE_TAG"]="$(date +'%Y%m%d_%H%M%S')"
    STEP_DATA["BASE_IMAGE_TAG"]="$(get_image_tag ${STEP_DATA['BASE_IMAGE']})"
    STEP_DATA["BASE_IMAGE"]="$(get_image_name ${STEP_DATA["BASE_IMAGE"]})"
    STEP_DATA["EXISTING_IMAGE"]="$(get_latest_image ${STEP_DATA["IMAGE_NAME"]})"

    local BASE_ARGS=$(printf "ARG BASE_IMAGE=%s\nARG BASE_IMAGE_TAG=%s" ${STEP_DATA["BASE_IMAGE"]} ${STEP_DATA["BASE_IMAGE_TAG"]})
    local ENV_ARGS=$(jq -r '.env.[]|split("=")|"ARG \(.[0])=\(.[1])"' <<< "$STEP_JSON")
    local BUILD_ARGS=$(printf "%s\n%s" "$BASE_ARGS" "$ENV_ARGS")

    STEP_DATA["CF_TEMPLATE"]=$(jq -r '.template' <<< "$STEP_JSON")
    STEP_DATA["CF_NAME"]=$(printf "%s-%s.Containerfile" ${STEP_DATA["IMAGE_NAME"]} ${STEP_DATA["IMAGE_TAG"]})
    STEP_DATA["CF_CONTENT"]=$(awk -v pat='^@@ BUILD_ARGS @@$' -v rep="$BUILD_ARGS" '{gsub(pat, rep)}1' containerfiles/${STEP_DATA["CF_TEMPLATE"]})

    if [[ -n "${STEP_DATA['EXISTING_IMAGE']}" && "${STEP_DATA["FORCE_NEW"]}" != "true" ]]; then
        STEP_DATA["SKIP_BUILD"]="true"
    else
        STEP_DATA["SKIP_BUILD"]="false"
    fi

    local BUILD_COMMAND=(
        podman build -f "$BUILD_DIR/${STEP_DATA['CF_NAME']}"
        --cgroup-manager cgroupfs
        -t "${STEP_DATA['IMAGE_NAME']}:${STEP_DATA['IMAGE_TAG']}"
        -t "${STEP_DATA['IMAGE_NAME']}:latest"
    )

    STEP_DATA["BUILD_COMMAND"]="${BUILD_COMMAND[@]}"
}


build_image() {

    local STEP_JSON="$1"
    declare -A STEP
    parse_step "$STEP_JSON" STEP

    LOG_FILE=$(printf "${BUILD_DIR}/%s-%s.log" "${STEP['IMAGE_NAME']}" "${STEP['IMAGE_TAG']}")

    if [[ ${STEP['SKIP_BUILD']} == "true" ]]; then
        log "Skipping build for ${STEP['IMAGE_NAME']}. Using existing image ${STEP['EXISTING_IMAGE']}:"
        podman image inspect ${STEP['EXISTING_IMAGE']} | log
        return
    fi

    if [[ -z "${STEP['BASE_IMAGE_TAG']}" ]]; then
        fail "TAG for BASE_IMAGE \"${STEP['BASE_IMAGE']}\" could not be determined"
    fi

    #check_var RECIPE BASE_IMAGE BUILD_ENV CONTAINERFILE FORCE_NEW IMAGE_NAME

    log "*** Build started $(date)"
    log "*** Building image: ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']}"
    log "*** Using Containerfile template: ${STEP['CF_TEMPLATE']}"
    log "*** Creating Containerfile: ${STEP['CF_NAME']}"

    echo "${STEP['CF_CONTENT']}" > "${BUILD_DIR}/${STEP['CF_NAME']}"

    log "*** Containerfile content:"
    cat "${BUILD_DIR}/${STEP['CF_NAME']}" | log

    log  "*** Base image: ${STEP['BASE_IMAGE']}:${STEP['BASE_IMAGE_TAG']}"
    log  "*** Base image information:"
    podman image inspect ${STEP['BASE_IMAGE']}:${STEP['BASE_IMAGE_TAG']}| log

    log "*** Starting build command: ${STEP['BUILD_COMMAND']}"

    eval "${STEP['BUILD_COMMAND']}" 2>&1 | log

    if [[ $? != 0 ]]; then
        # revisit: this never hits, even if the build command fails. podman always returns 0?
        fail "Build failed for ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']}"
    fi
    # revisit: also check the image was actually created

    log "*** Image info:"
    podman image inspect ${STEP['IMAGE_NAME']}:${STEP['IMAGE_TAG']}| log

    if [[ -n "${STEP['EXPORT_IMAGE_NAME']}" ]]; then
        export_image "${STEP['IMAGE_NAME']}" "${STEP['IMAGE_TAG']}" "${STEP['EXPORT_IMAGE_NAME']}" "${STEP['EXPORT_SIF_DEF']}"
    fi

    log "*** Build completed $(date)"

    printf "\n\n\n"
}

build_images() {
    # Execute all build steps from a recipe
    #
    echo "Building images from recipe $(yq . $RECIPE_FILE | jq -r '.name') at $RECIPE_FILE"

    yq -c . $RECIPE_FILE | jq -c '.steps.[]' | while IFS= read -r step; do
        build_image "${step}"
    done
}

dump_recipe() {
    # Print internal representation of each step of a recipe
    echo -e "Recipe $(yq . $RECIPE_FILE | jq -r '.name') from file $RECIPE_FILE:\n"

    yq -c . $RECIPE_FILE | jq -c '.steps.[]' | while IFS= read -r step_json; do
        declare -A step_data
        declare -p step_json
        parse_step "$step_json" step_data

        echo "  ${step_data['IMAGE_NAME']}"
        echo "    spec: $step_json"
        echo "    data:"

        for key in "${!step_data[@]}"; do
            printf "      %s: %s\n" $key "${step_data[$key]//$'\n'/\\n}"
        done

        echo
    done

}

show_commands() {
    # Perform a dry run based on generated recipe
    yq -c . $RECIPE_FILE | jq -c '.steps.[]' | while IFS= read -r step_json; do
        declare -A step_data
        parse_step "$step_json" step_data
        echo "${step_data['IMAGE_NAME']}:${step_data['IMAGE_TAG']}: ${step_data['BUILD_COMMAND']}"
        echo
    done
}

main() {
    # Set shell options
    set -e  # Exit on non-zero exit status
    #set -x  # Print executed commands

    # Ensure availability of required shell features
    if ! check_bash_features; then
        exit 1
    fi

    # If invalid number of arguments provided, print usage instructions
    if [ "$#" -ne 2 ] && [ "$#" -ne 3 ]; then
        usage
    fi

    # If invalid action provided, print usage instructions
    ACTION=$1
    if [ "$ACTION" != "build" ] && [ "$ACTION" != "dump" ] && [ "$ACTION" != "commands" ]; then
        usage
    fi

    # Ensure provided recipe file exists
    RECIPE_FILE=$2
    if [ ! -f "$RECIPE_FILE" ]; then
        echo "Error: Recipe file '$RECIPE_FILE' not found or not a file."
        usage
    fi

    # Ensure build directory exists, if provided
    if [ "$#" -eq 3 ]; then
        BUILD_DIR=$3
        if [ ! -d "$BUILD_DIR" ]; then
            echo "Error: Target directory '$BUILD_DIR' does not exist."
            usage
        fi
    fi

    # Execute provided action
    case "$ACTION" in
        "build")
            build_images $RECIPE_FILE
            ;;
        "dump")
            dump_recipe $RECIPE_FILE
            ;;
        "commands")
            show_commands $RECIPE_FILE
            ;;
        *)
            usage
            ;;
    esac
}

main "$@"
